<!DOCTYPE html>
<html>
<head>
    <title>RAMP Viewer Bookmark Decoder</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" />
</head>
<body>

<div class="container-fluid">
    <!-- Input field for the bookmark -->
    <div class="row">
        <div class="form-group col-md-12">
            <label>Encoded Bookmark (paste it in the box!)</label>
            <input class="form-control" type="text" id="encodebook" value="" />
            <button class="btn btn-default" id='cmdEnhance'>Enhance</button><button class="btn" id='cmdRaw'>Raw Decode</button>
        </div>

    </div>

    <div class="row"><div class="form-group col-md-12">
    </div></div>

    <!-- Outputs -->    
    <div class="row">
        <div class="form-group col-md-4">
            <label>Version</label>
            <input class="form-control" type="text" id="version" value="" />
        </div>
        <div class="form-group col-md-4">
            <label>Scale</label>
            <input class="form-control" type="text" id="scale" value="" />
        </div>
        <div class="form-group col-md-4">
            <label>Basemap</label>
            <input class="form-control" type="text" id="basemap" value="" />
        </div>
    </div>

    <div class="row">
        <div class="form-group col-md-4">
            <label>Map X</label>
            <input class="form-control" type="text" id="x" value="" />
        </div>
        <div class="form-group col-md-4">
            <label>Map Y</label>
            <input class="form-control" type="text" id="y" value="" />
        </div>
        <div class="form-group col-md-4">
            <label>Extra Box for Future Vars</label>
            <input class="form-control" type="text" id="blank" value="" />
        </div>
    </div>


    <div class="row"><div class="form-group col-md-12">
        <label>Layers</label>
        <select id="layers" size="10" class="form-control"></select>
    </div></div>

    <div class="row"><div class="form-group col-md-12">
        <label>Child Layers</label>
        <select id="childs" size="10" class="form-control"></select>
    </div></div>

    <div class="row"><div id="log" class="form-group col-md-12">
    </div></div>

    <!-- Input field for the bookmark -->
    <div class="row">
        <div class="form-group col-md-12">
            <label>Raw Decode</label>
            <input class="form-control" type="text" id="rawout" value="" />
        </div>

    </div>

</div>

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>

<script>
    
    var childDataStore = {};

    // decode from the customized base64 format
    function decode64(string) {
        return atob(string.replace(/_/g, '/').replace(/-/g, '+'));
    }

    // takes an array of properties, plus the property settings in bookmark encoding.
    // returns a human readable string of the properties
    function dataToText (props, info, version) {
        var lookup = {
            opacity: value => {
                if (version !== 'A' && value === '99') {
                    value = '100';
                }
                return parseInt(value) / 100
            },
            visibility: value => value === '1',
            boundingBox: value => value === '1',
            snapshot: value => value === '1',
            query: value => value === '1'
        };

        var result = '';

        props.forEach((prop, index) => {
            result += (prop + ': ' + lookup[prop](info[index]) + ', ' );
        });
        return result;
    }

    // returns a human readable string of properties for a child layer fragment of a bookmark
    function childDataToText(childData, version) {
        var cFormat = /^(\d{2})(\d{1})(\d{1})(.+?)$/;
        var cInfo = childData.match(cFormat);
        return 'service index: ' + cInfo[4] + ', ' + dataToText([, 'opacity', 'visibility', 'query'], cInfo, version);
    };

    // keeping things totally separate to avoid piles of IF statements

    function decodeVerA(bookmark) {

        var pattern = /^([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)(?:$|,(.*)$)/i;
        // things for specific layers:[ layer type name, regex to strip data from id, regex to parse data, property names in data ]
        var layerSpec = [
            ['Feature', /^(.+?)(\d{7})$/, /^(\d{3})(\d{1})(\d{1})(\d{1})(\d{1})$/, [, 'opacity', 'visibility', 'boundingBox', 'snapshot', 'query']],
            ['Wms', /^(.+?)(\d{6})$/, /^(\d{3})(\d{1})(\d{1})(\d{1})$/, [, 'opacity', 'visibility', 'boundingBox', 'query']],
            ['Tile', /^(.+?)(\d{5})$/, /^(\d{3})(\d{1})(\d{1})$/, [, 'opacity', 'visibility', 'boundingBox']],
            ['Dynamic', /^(.+?)(\d{6})$/, /^(\d{3})(\d{1})(\d{1})(\d{1})$/, [, 'opacity', 'visibility', 'boundingBox', 'query']],
            ['Image', /^(.+?)(\d{5})$/, /^(\d{3})(\d{1})(\d{1})$/, [, 'opacity', 'visibility', 'boundingBox']]
        ];
        
        var info = bookmark.match(pattern);
        var version = info[1];
        var decoded = [2, 3, 4, 5].map(i => decode64(info[i]));

        $('#version').val( 'A' );
        $('#scale').val( decoded[3] );
        $('#basemap').val( decoded[0] );
        $('#x').val( decoded[1] );
        $('#y').val( decoded[2] );

        var layerList = $('#layers')[0];
        clearList(layerList);
        childDataStore = {};

        if (info[6]) {
            var layers = info[6].split(',');

            // Generate text for all layers
            layers.forEach((layer, i) => {
                layer = decode64(layer);

                // strip out integer that defines the layer type
                var layerType = parseInt(layer.substring(0, 2));
                // split the remaining data into layer id and layer data
                var layerGuts = layer.substring(2).match(layerSpec[layerType][1]);
                var layerId = layerGuts[1];
                // parse the data into discrete parts, specific to the layer type
                var layerData = layerGuts[2].match(layerSpec[layerType][2]);

                // show the raw data, and then a human friendly version of it
                var opt = document.createElement("option");
                opt.text = layerSpec[layerType][0] + ' Layer, id: ' + layerId + ', ' +
                        dataToText(layerSpec[layerType][3], layerData, 'A');
                opt.value = i;
                layerList.add(opt);

            });

        }
    }

    function clearList(listControl) {
        while (listControl.firstChild) {
            listControl.removeChild(listControl.firstChild);
        }
    }

    function decodeVerB(bookmark) {
        var pattern = /^([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)(?:$|,(.*)$)/i;
        // things for specific layers:[ layer type name, regex to strip data from id, regex to parse data, property names in data ]
        var layerSpec = [
            ['Feature', /^(.+?)(\d{6})$/, /^(\d{2})(\d{1})(\d{1})(\d{1})(\d{1})$/, [, 'opacity', 'visibility', 'boundingBox', 'snapshot', 'query']],
            ['Wms', /^(.+?)(\d{5})$/, /^(\d{2})(\d{1})(\d{1})(\d{1})$/, [, 'opacity', 'visibility', 'boundingBox', 'query']],
            ['Tile', /^(.+?)(\d{4})$/, /^(\d{2})(\d{1})(\d{1})$/, [, 'opacity', 'visibility', 'boundingBox']],
            ['Dynamic', /^(.+?)([;].*\d{5})$/, /^(.+?)(\d{2})(\d{1})(\d{1})(\d{1})$/, [, 'opacity', 'visibility', 'boundingBox', 'query']],
            ['Image', /^(.+?)(\d{4})$/, /^(\d{2})(\d{1})(\d{1})$/, [, 'opacity', 'visibility', 'boundingBox']]
        ];

        var info = bookmark.match(pattern);
        var version = info[1];
        var decoded = [2, 3, 4, 5].map(i => decode64(info[i]));

        // if we have the blank flag set, format it nicely
        var basemap = decoded[0].substring(0, decoded[0].length - 1);
        if (decoded[0].substr(decoded[0].length - 1, 1) === '1') {
            basemap = `blank basemap [${basemap}]`;
        }

        $('#version').val( 'B' );
        $('#scale').val( decoded[3] );
        $('#basemap').val( basemap );
        $('#x').val( decoded[1] );
        $('#y').val( decoded[2] );

        var layerList = $('#layers')[0];
        clearList(layerList);
        childDataStore = {};

        if (info[6]) {
            var layers = info[6].split(',');

            // Generate text for all layers
            layers.forEach((layer, i) => {
                layer = decode64(layer);

                // strip out integer that defines the layer type
                var layerType = parseInt(layer.substring(0, 2));
                // split the remaining data into layer id and layer data
                var layerGuts = layer.substring(2).match(layerSpec[layerType][1]);
                var layerId = layerGuts[1];
                // parse the data into discrete parts, specific to the layer type
                var layerData = layerGuts[2].match(layerSpec[layerType][2]);
                
                // rip off child data if we are dynamic
                if (layerType === 3) {

                    var textArray = [];
                    var childData = layerData[1].substr(1); // drop leading ;
                    layerData.splice(1, 1); // remove child info from array, normalizing it with the other layer types

                    // process the children and store them in our persistant var, so it can be accessed if someone clicks on the parent

                    // splitting on ; gives us chunks of data for each top-level index in the layer.
                    // i.e. each chunk defines an object that goes in .layerEntries
                    childData.split(';').forEach(function (cData) {
                        // for a single top level index, we can also have auto-generated child settings along with it.
                        // these values are separated by ` chars. The first one is always the parent.
                        var subChildData = cData.split('`');

                        // make parent entry, then remove it from source array
                        textArray.push( 'Parent: ' + childDataToText(subChildData[0], 'B'));
                        subChildData.splice(0, 1);

                        // if any child data remains, add it to the text array
                        subChildData.forEach(function (scd) {
                            textArray.push( '--Child: ' + childDataToText(scd, 'B'));
                        });
                    });

                    childDataStore[i.toString()] = textArray;

                }

                // show the raw data, and then a human friendly version of it
                var opt = document.createElement("option");
                opt.text = layerSpec[layerType][0] + ' Layer, id: ' + layerId + ', ' +
                        dataToText(layerSpec[layerType][3], layerData, 'B');
                opt.value = i;
                layerList.add(opt);

            });
           
        }
    }

    $(document).ready(function () {

        $('#cmdEnhance').click( function() {
            // enhance the bookmark into human readable form

            var bookmark = $('#encodebook').val();

            // if full URL is supplied, only take the rv param
            var keyStart = bookmark.indexOf('rv=');
            if (keyStart > -1) {
                var nextAnd = bookmark.indexOf('&', keyStart + 3);
                if (nextAnd === -1) {
                    // no more url params after the bookmark, so set it up to read to the end of the string
                    nextAnd = bookmark.length;
                }
                bookmark = bookmark.substring(keyStart + 3, nextAnd);
            } 

            var version = bookmark.match(/^([^,]+)/)[0];
             
            switch (version) {
                case 'A':
                    decodeVerA(bookmark);
                    break;
                case 'B':
                    decodeVerB(bookmark);
                    break;
            }

        });
       
        $('#cmdRaw').click( function() {
            // enhance the bookmark into human readable form

            var bookmark = $('#encodebook').val();

            // if full URL is supplied, only take the rv param
            var keyStart = bookmark.indexOf('rv=');
            if (keyStart > -1) {
                var nextAnd = bookmark.indexOf('&', keyStart + 3);
                if (nextAnd === -1) {
                    // no more url params after the bookmark, so set it up to read to the end of the string
                    nextAnd = bookmark.length;
                }
                bookmark = bookmark.substring(keyStart + 3, nextAnd);
            } 

            var rawOut = bookmark.split(',').map(function(nugget, idx) {
                if (idx === 0) {
                    return nugget;
                } else {
                    return decode64(nugget);
                }
            }).join(',');
           
            $('#rawout').val( rawOut );
            
        });

        $('#layers').click( function(e) {
            var idx = e.currentTarget.value;
            var childList = $('#childs')[0];

            clearList(childList);

            if (childDataStore[idx]) {
                // add some child stuff
                var textArray = childDataStore[idx];
                textArray.forEach(function(t, i) {

                    var opt = document.createElement("option");
                    opt.text = t;
                    opt.value = i;
                    childList.add(opt);

                });
            }
        });

    });
</script>

</body>
</html>
